# syntax=docker/dockerfile:1.4
# 使用 Arch Linux 基础镜像尝试构建完全静态链接的 DEBUG 版本

# --- OpenCC 和 Marisa 版本 (与之前保持一致) ---
ARG OPENCC_VERSION=1.1.7
ARG MARISA_VERSION=0.2.6

# 阶段 0: 在 Arch Linux 上构建 OpenCC 和 Marisa-trie 静态库
FROM archlinux:latest AS opencc_builder
ARG OPENCC_VERSION
ARG MARISA_VERSION
WORKDIR /opt

# 更新 Arch Linux 包数据库并安装基础编译工具和依赖
# 'base-devel' 包含 gcc, make 等。
# 需要确保安装了静态库版本的 glibc, libstdc++ 等 (这在 Arch 上可能需要特定包或已默认包含)
RUN pacman -Syu --noconfirm \
    base-devel \
    cmake \
    wget \
    python \
    git \
    # autoconf automake libtool 通常是 base-devel 的一部分或可单独安装
    autoconf \
    automake \
    libtool && \
    # 清理 pacman 缓存
    pacman -Scc --noconfirm

# 下载、编译并安装 Marisa-trie
RUN wget https://github.com/s-yata/marisa-trie/archive/refs/tags/v${MARISA_VERSION}.tar.gz -O marisa.tar.gz && \
    tar xzf marisa.tar.gz && \
    cd marisa-trie-${MARISA_VERSION} && \
    autoreconf -i && \
    # 注意：在 Glibc 环境下，--enable-static --disable-shared 仍然适用
    LDFLAGS="-static" ./configure --prefix=/usr/local --enable-static --disable-shared && \
    make -j$(nproc) && \
    make install && \
    cd .. && rm -rf marisa-trie-${MARISA_VERSION} marisa.tar.gz

# 下载、编译并安装 OpenCC
RUN wget https://github.com/BYVoid/OpenCC/archive/refs/tags/ver.${OPENCC_VERSION}.tar.gz -O opencc.tar.gz && \
    tar xzf opencc.tar.gz && \
    cd OpenCC-ver.${OPENCC_VERSION} && \
    cmake . \
        -DCMAKE_BUILD_TYPE=Debug \
        -DBUILD_SHARED_LIBS=OFF \
        # 确保启用了 Marisa 支持
        -DENABLE_MARISA=ON \
        -DCMAKE_INSTALL_PREFIX=/usr/local && \
    make -j$(nproc) && \
    make install && \
    cd .. && rm -rf OpenCC-ver.${OPENCC_VERSION} opencc.tar.gz

# 阶段 1: Rust 环境准备和依赖编译 (cargo-chef)
FROM archlinux:latest AS chef
WORKDIR /app

# 安装基础编译工具、OpenSSL 和 curl (用于下载 rustup-init)
RUN pacman -Syu --noconfirm \
    base-devel \
    openssl \
    pkgconf \
    curl \
    git && \
    pacman -Scc --noconfirm

# 安装 Rust 工具链使用官方脚本，并确保 PATH 更新
# 将 rustup 安装、PATH 设置、以及 rustup target add 放在同一个 RUN 指令中
# 以确保 PATH 在后续命令中生效
ENV PATH="/root/.cargo/bin:${PATH}"
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable --profile minimal && \
    # rustup-init 脚本会自动将 /root/.cargo/bin 添加到 PATH，但通常只对新的 shell 会话生效
    # 所以我们在这里显式使用完整路径来调用 rustup，或者确保 ENV PATH 已更新并被此 RUN 指令的 shell 会话采纳
    # 为了保险起见，后续的 rustup 调用也使用完整路径
    /root/.cargo/bin/rustup target add x86_64-unknown-linux-gnu && \
    echo 'export PATH=/root/.cargo/bin:$PATH' >> /root/.bashrc # 或者 /etc/profile.d/rustup.sh

# 复制 OpenCC 和 Marisa
COPY --from=opencc_builder /usr/local /usr/local

RUN cargo install cargo-chef --locked
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

# 阶段 2: 构建所有依赖项 (planner 阶段 - Debug 模式)
FROM archlinux:latest AS planner
WORKDIR /app
# 确保 Rust 工具链在 PATH 中
ENV PATH="/root/.cargo/bin:${PATH}"

# 复制 OpenCC 和 Marisa
COPY --from=opencc_builder /usr/local /usr/local
# 复制 rustup 安装的 cargo 和 rustc
COPY --from=chef /root/.cargo /root/.cargo
COPY --from=chef /usr/local/bin/cargo-chef /usr/local/bin/cargo-chef
COPY --from=chef /app/recipe.json recipe.json

# 安装编译依赖 (确保此阶段也有)
RUN pacman -Syu --noconfirm \
    base-devel \
    openssl \
    pkgconf && \
    pacman -Scc --noconfirm

# 设置 opencc-rust crate 所需的环境变量
ENV OPENCC_STATIC=1
ENV OPENCC_LIB_DIRS=/usr/local/lib
ENV OPENCC_LIBS=opencc:marisa
ENV OPENCC_INCLUDE_DIRS=/usr/local/include
# 尝试让 build.rs 处理 libstdc++
ENV OPENCC_DYLIB_STDCPP=1

# 尝试静态链接 OpenSSL
ENV OPENSSL_STATIC=1
# 对于 Glibc 下的完全静态链接，RUSTFLAGS 会非常关键
# LDFLAGS="-static" 可能需要在编译 C/C++ 依赖时也设置
# 尝试静态链接C运行时
ENV RUSTFLAGS="-C target-feature=+crt-static"
ENV PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH}"
# 提示 pkg-config 寻找静态库
ENV PKG_CONFIG_ALL_STATIC=1

RUN cargo chef cook --target x86_64-unknown-linux-gnu --recipe-path recipe.json

# 阶段 3: 构建应用程序本身 (Debug 模式)
FROM archlinux:latest AS builder
WORKDIR /app
# 确保 Rust 工具链在 PATH 中
ENV PATH="/root/.cargo/bin:${PATH}"

# 复制 OpenCC 和 Marisa
COPY --from=opencc_builder /usr/local /usr/local
COPY --from=planner /app/target target
# 复制 cargo 和 rustc
COPY --from=planner /root/.cargo /root/.cargo
# 如果需要
COPY --from=planner /usr/local/bin/cargo-chef /usr/local/bin/cargo-chef

# 安装编译依赖 (确保此阶段也有)
RUN pacman -Syu --noconfirm \
    base-devel \
    openssl \
    pkgconf && \
    pacman -Scc --noconfirm

COPY . .

# 设置 .cargo/config.toml 指定 g++ 作为链接器并使用强制静态链接参数
# 对于 Arch (Glibc)，完全静态链接非常困难，通常不推荐，但我们尝试
RUN mkdir -p .cargo && \
    echo '[target.x86_64-unknown-linux-gnu]' > .cargo/config.toml && \
    echo 'linker = "g++"' >> .cargo/config.toml && \
    # 尝试让 g++ 进行全面静态链接，这在 Glibc 系统上可能导致问题，但符合“完全静态编译”的尝试
    # Glibc 自身很多部分不希望被完全静态链接，尤其是 nss 等
    # 更稳妥的做法可能是静态链接所有能静态链接的，然后接受对基础 glibc 的动态链接
    # 但既然目标是“完全静态”，我们先尝试最强的选项
    echo 'rustflags = [' >> .cargo/config.toml && \
    echo '  "-C", "target-feature=+crt-static",' >> .cargo/config.toml && \
    echo '  "-C", "link-arg=-static",' >> .cargo/config.toml && \
    # echo '  "-C", "link-arg=-static-libstdc++",' >> .cargo/config.toml && \
    # echo '  "-C", "link-arg=-static-libgcc",' >> .cargo/config.toml && \
    echo '  "-C", "link-arg=-lpthread",' >> .cargo/config.toml && \
    # 有时静态链接也需要 dl
    echo '  "-C", "link-arg=-ldl"' >> .cargo/config.toml && \
    echo ']' >> .cargo/config.toml

# 再次设置环境变量
ENV OPENCC_STATIC=1
ENV OPENCC_LIB_DIRS=/usr/local/lib
ENV OPENCC_LIBS=opencc:marisa
ENV OPENCC_INCLUDE_DIRS=/usr/local/include
ENV OPENCC_DYLIB_STDCPP=1

# 虽然不是交叉编译，但有时有用
ENV PKG_CONFIG_ALLOW_CROSS=1
ENV OPENSSL_STATIC=1
ENV PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH}"
ENV PKG_CONFIG_ALL_STATIC=1

RUN cargo build --target x86_64-unknown-linux-gnu --bin crslab_comments_reptile --verbose
RUN mv target/x86_64-unknown-linux-gnu/debug/deps/crslab_comments_reptile /crslab_comments_reptile_debug_glibc_static_attempt

# 最终阶段：从一个干净的 scratch 或 alpine 镜像开始，只复制二进制文件
# 但如果目标是 Glibc 完全静态，它可能仍然只在 Glibc 系统上运行
FROM scratch
COPY --from=builder /crslab_comments_reptile_debug_glibc_static_attempt /crslab_comments_reptile_debug
ENTRYPOINT ["/crslab_comments_reptile_debug"]