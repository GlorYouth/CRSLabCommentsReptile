# syntax=docker/dockerfile:1.4
# 用于构建 crslab_comments_reptile Rust 应用程序 DEBUG 版本的 Dockerfile (使用 musl 目标)
# 此版本会从源码编译 OpenCC (及其依赖 Marisa) 以实现静态链接，
# 并主要通过 opencc-rust crate 的环境变量来指导链接。

# --- OpenCC 和 Marisa 版本 ---
ARG OPENCC_VERSION=1.1.7
ARG MARISA_VERSION=0.2.6 # Marisa-trie 版本

# 阶段 0: 构建 OpenCC 和 Marisa-trie 静态库
FROM alpine:3.18 AS opencc_builder
ARG OPENCC_VERSION
ARG MARISA_VERSION
WORKDIR /opt

# 安装编译依赖
RUN apk add --no-cache \
    cmake \
    make \
    g++ \
    util-linux \
    wget \
    python3 \
    autoconf \
    automake \
    libtool # Marisa-trie 需要 autotools

# 下载、编译并安装 Marisa-trie (OpenCC 的依赖)
RUN wget https://github.com/s-yata/marisa-trie/archive/refs/tags/v${MARISA_VERSION}.tar.gz -O marisa.tar.gz && \
    tar xzf marisa.tar.gz && \
    cd marisa-trie-${MARISA_VERSION} && \
    autoreconf -i && \
    ./configure --prefix=/usr/local --enable-static --disable-shared && \
    make -j$(nproc) && \
    make install && \
    cd .. && rm -rf marisa-trie-${MARISA_VERSION} marisa.tar.gz

# 下载 OpenCC 源码
RUN wget https://github.com/BYVoid/OpenCC/archive/refs/tags/ver.${OPENCC_VERSION}.tar.gz -O opencc.tar.gz && \
    tar xzf opencc.tar.gz && \
    rm opencc.tar.gz

# 编译并安装 OpenCC 静态库
RUN cd OpenCC-ver.${OPENCC_VERSION} && \
    cmake . \
        -DCMAKE_BUILD_TYPE=Debug \
        -DBUILD_SHARED_LIBS=OFF \
        -DENABLE_MARISA=ON \ # 确保启用了 Marisa 支持
        -DCMAKE_INSTALL_PREFIX=/usr/local && \
    make -j$(nproc) && \
    make install

# 阶段 1: 构建依赖 (使用 cargo-chef 进行优化)
FROM rust:alpine AS chef
WORKDIR /app
COPY --from=opencc_builder /usr/local /usr/local # 复制 OpenCC 和 Marisa
RUN apk add --no-cache musl-dev build-base openssl-dev gcc g++ perl pkgconfig
RUN cargo install cargo-chef --locked
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

# 阶段 2: 构建所有依赖项 (planner 阶段 - Debug 模式)
FROM rust:alpine AS planner
WORKDIR /app
COPY --from=opencc_builder /usr/local /usr/local # 复制 OpenCC 和 Marisa
COPY --from=chef /usr/local/cargo/bin/cargo-chef /usr/local/bin/cargo-chef
RUN chmod +x /usr/local/bin/cargo-chef
COPY --from=chef /app/recipe.json recipe.json
RUN apk add --no-cache musl-dev build-base openssl-dev gcc g++ perl pkgconfig
RUN rustup target add x86_64-unknown-linux-musl

# 设置 opencc-rust crate 所需的环境变量
ENV OPENCC_STATIC=1
ENV OPENCC_LIB_DIRS=/usr/local/lib
ENV OPENCC_LIBS=opencc:marisa # 明确链接 opencc 和 marisa
ENV OPENCC_INCLUDE_DIRS=/usr/local/include
ENV OPENCC_DYLIB_STDCPP=1 # 关键：指示 build.rs 处理 libstdc++ 的链接

ENV OPENSSL_STATIC=1 # 保持 OpenSSL 静态链接
ENV RUSTFLAGS="-C target-feature=+crt-static" # 基础静态链接标志 (主要影响 chef cook 阶段的依赖)
ENV PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH}"

RUN cargo chef cook --target x86_64-unknown-linux-musl --recipe-path recipe.json

# 阶段 3: 构建应用程序本身 (Debug 模式)
FROM rust:alpine AS builder
WORKDIR /app
COPY --from=opencc_builder /usr/local /usr/local # 复制 OpenCC 和 Marisa
COPY --from=planner /app/target target
COPY --from=planner /usr/local/cargo /usr/local/cargo
RUN apk add --no-cache musl-dev build-base openssl-dev gcc g++ perl pkgconfig 

COPY . .
RUN rustup target add x86_64-unknown-linux-musl

# 设置 .cargo/config.toml 指定 g++ 作为链接器并设置基础静态链接标志
# 期望 OPENCC_DYLIB_STDCPP=1 会让 build.rs 添加 -lstdc++，然后 g++ -static 会处理它
RUN mkdir -p .cargo && \
    echo '[target.x86_64-unknown-linux-musl]' > .cargo/config.toml && \
    echo 'linker = "g++"' >> .cargo/config.toml && \
    echo 'rustflags = ["-C", "target-feature=+crt-static", "-C", "link-arg=-static"]' >> .cargo/config.toml

# 再次设置环境变量，确保它们在 cargo build 阶段也生效
ENV OPENCC_STATIC=1
ENV OPENCC_LIB_DIRS=/usr/local/lib
ENV OPENCC_LIBS=opencc:marisa
ENV OPENCC_INCLUDE_DIRS=/usr/local/include
ENV OPENCC_DYLIB_STDCPP=1

ENV PKG_CONFIG_ALLOW_CROSS=1 
ENV OPENSSL_STATIC=1 
ENV PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH}"

RUN cargo build --target x86_64-unknown-linux-musl --bin crslab_comments_reptile --verbose
RUN mv target/x86_64-unknown-linux-musl/debug/crslab_comments_reptile /crslab_comments_reptile_debug_final

